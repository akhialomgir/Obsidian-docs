#fleeting #algorithm 

# 242.有效的字母异位词

```js
//数组哈希
var isAnagram = function (s, t) {
    if (s.length !== t.length) return false; //长度不相等直接返回
    const map = new Array(26).fill(0); //连续有限字符使用数组更简单
    const base = "a".charCodeAt(); //重要方法：charCodeAt
    for (const c of s) map[c.charCodeAt() - base]++;
    for (const c of t) {
        if (!map[c.charCodeAt() - base]) return false; //0：s未出现或即将到-1
        map[c.charCodeAt() - base]--;
    }
    return true;
};
```

```js
//Map对象
var isAnagram = function (s, t) {
    if (s.length !== t.length) return false;
    const map = new Map();
    for (c of s) {
        const count = map.get(c);
        map.set(c, count === undefined ? 1 : count + 1);
    }
    console.log(map);
    for (c of t) {
        const count = map.get(c);
        if (!count) return false;
        map.set(c, count === undefined ? 1 : count - 1);
    }
    return true;
};
```

# 1002. 查找常用字符

```js
//我的解法：哈希表，最小值
var commonChars = function (words) {
    const m = new Array(26).fill(Infinity);
    const base = "a".charCodeAt();
    const ans = [];

    for (const word of words) {
        const counter = new Array(26).fill(0);
        for (const c of word) {
            counter[c.charCodeAt() - base]++;
        }
        for (let i = 0; i < 26; i++) {
            if (counter[i] < m[i]) m[i] = counter[i];
        }
    }
    for (let i = 0; i < 26; i++) {
        while (m[i]--) ans.push(String.fromCharCode(base + i));
    }
    return ans;
};
```

```js
//等量筛除法
var commonChars = function (words) {
    let ans = [], word = words[0];
    for (let c of word) {
        if (words.every(m => m.includes(c))) {
            words = words.map(m => m.replace(c, ''));
            ans.push(c);
        }
    }
    return ans;
};
```


```js
//我的解法：集合
var intersection = function (nums1, nums2) {
    const s = new Set(nums2), ans = new Set();
    for (const n of nums1) {
        if (s.has(n)) ans.add(n);
    }
    return Array.from(ans);
};
```